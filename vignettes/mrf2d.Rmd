---
title: "A guide to mrf2d"
output: 
  rmarkdown::html_vignette:
    number_sections: true
vignette: >
  %\VignetteIndexEntry{A guide to mrf2d}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../inst/REFERENCES.bib
nocite: |
  @wiki_sa, @wiki_pl
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r load_mrf2d}
library(mrf2d)
```

# Introduction

## A quick introduction to Markov Random Fields

 Markov Random Fields are probabilistic models used for modeling processes with local dependence. This dependence can be described by a graph $\mathcal{G} = (\mathcal{V}, \mathcal{N})$, where $\mathcal{V}$ is a set of vertices and $\mathcal{N}$ a neighborhood system.

$$ P_\theta(\mathbf{Z} = \mathbf{z}) = \frac{1}{\zeta_\theta} \exp \left( \sum_{q \in Q} g_q(\mathbf z_q, \theta) \right) $$

## A spatially stationary MRF model for 2-dimensional lattices

## The `mrf2d` package

`mrf2d` has the goal to provide tools for analysis of Markov Random Fields on two-dimensional lattices, mainly, by defining a well-designed representation of the interaction structure, as well as parameters sets with different types of restrictions. It also exports efficient implementations of the most commom estimation methods and a sampling function, making it easy to implement new or specific algorithms with little effort taking advantage of the the package's API.

Computational efficiency is also a feature of the package, having most of the high-cost core functions written with `Rcpp` backend and representations thoughtfully designed for high performance.

The package also provides [plotting](https://freguglia.github.io/mrf2d/reference/dplot.html) functions `dplot()` and `cplot()` that automatically convert `matrix` objects to appropriate `data.frame` structures and creates `ggplot` objects from it. These functions aim to provide easy to use methods of visualization but also take advantage of [`ggplot2`](https://ggplot2.tidyverse.org/)'s grammar to modify aesthetics and create elegant and customizable visualizations of lattice data. `dplot()` should be used for **d**iscrete data while `cplot()` is suitable for **c**ontinuous data.

```{r plots_examples, fig.width = 4, warning=FALSE}
class(Z_potts)
unique(as.vector(Z_potts))

dplot(Z_potts, legend = TRUE)
cplot(Z_potts + rnorm(length(Z_potts)))

library(ggplot2)
dplot(Z_potts) + ggtitle("Title added with ggplot2")
dplot(Z_potts) + scale_fill_brewer(type = "qual") + 
  ggtitle("Title added with ggplot2")
```


# The `mrfi` class and parameter arrays

The stationary Markov Random Fields described are completely specified by the set of relative positions where interactions exists $\mathcal{R}$ and the interaction parameters $\theta_{a,b,r}$, $(a,b) \in \{0,\dots,C \}^2, r \in \mathcal{R}$.

In `mrf2d`, interaction structures $\mathcal{R}$ are represented by objects of the S4 class `mrfi`, while interaction parameters are reprensted by simple 3-dimensional arrays, where `theta[a,b,k]` contains the value of $\theta_{a,b,r}$ for the $k$-th relative position. As an example, in a nearest-neighbor structure ($|\mathcal{R}| = 2$) with $C = 1$, where the interaction for equal values ($a=b$) is `0` and `-0.99` for different values, the corresponding array would be

```{r theta_example}
mrf2d:::vec_to_array(-0.99, "onepar", 1, 2)
```

Note how rows represents values $a$, columns are values of $b$ and slices are the relative positions in $\mathcal{R}$.

## Creating `mrfi` objects

`mrfi` objects can be created with the `mrfi()` function. It takes three parameters: `max_norm`, `norm_type` and `positions`. `max_norm` and `norm_type` combined define a region where interactions are included. As example, if `max_norm` is `3` and `norm_type` is `"1"`, the interaction structure will include relative positions $r$ where $|r_x| + |r_y| \leq 3$.

Note that opposite positions, e.g., $(1,0)$ and $(-1,0)$ are not both included, as the second one is always redundant for the model. A `plot()` method is available to visualize `mrfi` objects.

```{r}
mrfi(max_norm = 3, norm_type = "1")
```


## Parameter restriction families

### family `'onepar'`

The interaction depends only if the pair of values is equal or different and not on their values or relative position. Since we set $\theta_{0,0,r} = 0$, this simplifies as:

$$ \theta_{a,b,r} = \theta \mathbb{1}_{[a \neq b]} $$

Example of valid array for `'onepar'`:

```{r, echo = FALSE}
mrf2d:::vec_to_array(-0.01, family = "onepar", C = 2, 2)
```


### family `'oneeach'`

The same as `'onepar'`, but allowing different values for different relative positions $r$, resulting a total of $|\mathcal{R}|$ free parameters:

$$ \theta_{a,b,r} = \theta_r \mathbb{1}_{[a \neq b]} $$

Example of valid array for `'oneeach'`:

```{r, echo = FALSE}
mrf2d:::vec_to_array(c(-0.01, -0.02), family = "oneeach", C = 2, 2)
```

### family `'absdif'`

The values with equal absolute differences ($|b-a|$) are kept constant within each relative position, resulting a total of $|\mathcal{R}| \cdot C$ free parameters. Note that the restriction $\theta_{0,0,r} = 0$ implies all pairs with absolute difference equals $0$ will also be null. 

$$ \theta_{a,b,r} = \theta_{|b-a|,r} $$

Example of valid array for `'absdif'`:

```{r, echo = FALSE}
mrf2d:::vec_to_array(c(-0.01, -0.02, -0.03, -0.04), family = "absdif", C = 2, 2)
```

### family `'dif'`

The same as `'absdif'`, but allowing different values for positive and negative differences, i.e., $\theta_{a,b,r} \neq \theta_{b,a,r}$ for $a \neq b$. This restriction allows different effects on opposing directions to exist.

Note that `'dif'` and `'absdif'` are typically used when the observed values actually have a quantitative meaning (as the gray levels of images), but not in tasks like image segmentation, where the value describes a class where, usually, the order and therefore differences have no meaning.

$$ \theta_{a,b,r} = \theta_{b-a,r}$$

Example of valid array for `'dif'`:

```{r, echo = FALSE}
mrf2d:::vec_to_array(c(-0.01, -0.02, -0.03, -0.04, -0.05, -0.06, -0.07, -0.08), family = "dif", C = 2, 2)
```

### family `'free'`

No additional restriction. The identifiability constraint $\theta_{0,0,r} = 0$ is still necessary.

Example of valid array for `'free'`:

```{r, echo = FALSE}
mrf2d:::vec_to_array(seq(-0.01, -0.16, by = -0.01), family = "free", C = 2, 2)
```

# Parameter estimation on Markov Random Fields

## Pseudo-Likelihood

$$ PL(\theta;\mathbf{z}) = \prod_{i \in \mathcal{L}} P(Z_i = z_i | \mathbf{Z}_{\mathcal{N}_i} = \mathbf{z}_{\mathcal{N}_i}) $$

```{r}
fit_pl(Z_potts, mrfi(1), family = "onepar")

fit_pl(Z_potts, mrfi(1), family = "oneeach")
```



## Stochastic Approximation

Stochastic Approximation is an algorithm for finding a (concave) function's maximum value without the need to evaluate it. Instead, it iteratively moves a solution in the gradient's direction

The likelihood function of the MRF defined above belongs to the exponential family and can be written as 

$$ l(\theta;\mathbf{z}^0) = (S(\mathbf{z}^0) \bullet \theta) -  \log(\zeta_\theta),$$
where $\bullet$ denotes the dot product and $S(\mathbf{z})$ is the vector sufficient statistics. Therefore, the global maximum is the point where the gradient $\frac{\partial}{\partial \theta} l(\theta;\mathbf{z}^0)$ is equal to zero, and the gradient is given by
$$\frac{\partial}{\partial \theta} l(\theta;\mathbf{z}^0) = S(\mathbf{z}^0) - \mathbb{E}_\theta(S(\mathbf{Z})).$$

Starting from an arbitrary configuration $\theta^{(1)}$, which is considered the null vector by default in `mrf2d`, the algorithm iteratively samples a field $\mathbf{z}^{(t)}$ from the current parameter configuration $\theta^{(t)}$ and then updates $\theta^{(t+1)}$ according to an estimated gradient direction in the following recursion
$$ \theta^{(t+1)} = \theta^{(t)} + \gamma^{(t)} \left( S(\mathbf{z}^0) - S(\mathbf{z}^{(t)}) \right).$$

Some notes and details about `mrf2d`'s implementation of the Stochastic Approximation algorithm (function `fit_sa()`):

  * Exact sampling from a MRF either has a high computational cost or is an intractable problem, therefore, iterative methods (here, the Gibbs Sampler) are used. Since these methods may take a large number of cycles to reach the equilibrium distribution, the last sampled field is cached and used as an initial value for the next sample, with a smaller number of cycles between interactions. This was used for example in @gimel1996texture.
  * Two additional parameters are used in our implementation: `refresh_each` and `refresh_cycles`. If specified, the sampled field $\mathbf{z}^t$ will be completely reset each `refresh_each` iterations. Whenever the field is reset, a new one will be sampled from a random initial configuration and a number of cycles equals to `refresh_cycles`, which should typically be a large value. Extreme cases are `refresh_each = 1`, where a completely new field is generated in each iteration (very slow) and `refresh_each` larger than the number of iterations (function's defaults), which means no refresh will ever happen. 
  * The algorithm requires the theoretical restrictions $\sum_t \gamma^{(t)} = +\infty$ and $\sum_t \left(\gamma^{(t)}\right)^2 < +\infty$. Since in practice only a finite number of iterations is executed, the choice of the $\gamma^{(t)}$ sequence requires some tuning to improve the results obtained.
  * The sequence $\gamma^{(t)}$ is specified by the parameter `gamma_seq`, but the values are divided by `length(Z)`. This standardizes the notion of what is a "small" or "large" value for the step size regardless of the lattice dimensions.
  * A `data.frame` containing the distances $|| \mathbf{z}^0 - \mathbf{z}^{(t)} ||^2_2$ is returned in the `metrics` field. It can be used to monitor the convergence of the algorithm.
  
```{r fit_sa_examples, cache = TRUE, fig.width=6}
set.seed(1234)
sa_onepar <- fit_sa(Z_potts, mrfi(1), family = "onepar", 
                    gamma_seq = seq(3, 0, length.out = 200))
sa_onepar$theta

sa_oneeach <- fit_sa(Z_potts, mrfi(1), family = "oneeach", 
                    gamma_seq = seq(3, 0, length.out = 200))
sa_oneeach$theta
plot(sa_oneeach$metrics[2:200,])
```


# Hidden Markov Random Fields

## Gaussian Mixtures

@zhang2001segmentation

$$ f(\mathbf{y}|\mathbf{Z} = \mathbf{z}) = \prod_{i \in \mathcal{L}} \frac{1}{\sqrt{2\pi \sigma^2}} \exp \left( - \frac{(y_i - \mu_{Z_i})^2}{2\sigma^2} \right) $$

# Bibliography
